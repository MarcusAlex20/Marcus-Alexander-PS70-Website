#include <Adafruit_NeoPixel.h>
#include <Wire.h>
#include <Adafruit_MPU6050.h>

// Constants
#define PIN 8 // LED strip data pin
#define NUMPIXELS 10 // Number of LEDs in the strip

#define ANALOG_PIN_1 A0 // Analog input for sensor 1
#define ANALOG_PIN_2 A1 // Analog input for sensor 2
#define TX_PIN_1 7 // Capacitor sensing TX pin for sensor 1
#define TX_PIN_2 6 // Capacitor sensing TX pin for sensor 2
#define BUTTON_PIN 9 // Pin for the reset button

#define DECAY_FACTOR 0.98 // Decay factor applied to cumulative force over time
#define FLASH_DURATION 2000 // Flash duration in milliseconds
#define FLASH_INTERVAL 200 // Interval between flashes in milliseconds
#define CUMULATIVE_FORCE_THRESHOLD 500 // Combined threshold for cumulative force to trigger flashing
#define SIGNIFICANT_STRIKE_THRESHOLD 50 // Threshold for a significant strike
#define STRIKE_THRESHOLD 10 // Threshold for a one-off strike
#define ROUND_DURATION 180000 // Match round duration in milliseconds (3 minutes)

// Initialize NeoPixel strip
Adafruit_NeoPixel strip(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);

// Initialize accelerometer
Adafruit_MPU6050 mpu;

// Metrics
float cumulativeForce = 0; // Combined cumulative force from both sensors
int totalHits = 0; // Total number of hits
int significantHits = 0; // Total number of significant strikes
int oneOffStrikes = 0; // Total number of one-off strikes
int fighter1Score = 0; // Score for fighter 1
int fighter2Score = 0; // Score for fighter 2
unsigned long matchStartTime; // Start time of the match
unsigned long flashStartTime; // Start time of flashing
bool redMode = false; // Flag for red flashing mode

// Baselines
int baseline1 = 0;
int baseline2 = 0;

// Accelerometer metrics
float velocity = 0; // Velocity of head movement
float accelerationThreshold = 2.0; // Threshold for significant acceleration

// Function to calibrate baseline
int calibrateBaseline(int analogPin, int txPin) {
  int total = 0;
  for (int i = 0; i < 100; i++) {
    digitalWrite(txPin, HIGH);
    delayMicroseconds(10);
    int readHigh = analogRead(analogPin);
    digitalWrite(txPin, LOW);
    delayMicroseconds(10);
    int readLow = analogRead(analogPin);
    total += (readHigh - readLow);
  }
  return total / 100; // Return the average as the baseline
}

// Function to measure capacitance difference
int txRx(int analogPin, int txPin) {
  digitalWrite(txPin, HIGH);
  delayMicroseconds(10);
  int readHigh = analogRead(analogPin);
  digitalWrite(txPin, LOW);
  delayMicroseconds(10);
  int readLow = analogRead(analogPin);
  return readHigh - readLow;
}

// Function to reset metrics
void resetMetrics() {
  cumulativeForce = 0;
  totalHits = 0;
  significantHits = 0;
  oneOffStrikes = 0;
  fighter1Score = 0;
  fighter2Score = 0;
  baseline1 = calibrateBaseline(ANALOG_PIN_1, TX_PIN_1);
  baseline2 = calibrateBaseline(ANALOG_PIN_2, TX_PIN_2);
  Serial.println("Metrics and baselines reset.");
}

// Function to calculate velocity from accelerometer
float calculateVelocity() {
  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);

  // Calculate velocity based on acceleration
  float acceleration = sqrt(a.acceleration.x * a.acceleration.x +
                             a.acceleration.y * a.acceleration.y +
                             a.acceleration.z * a.acceleration.z);
  return acceleration;
}

void setup() {
  // Initialize serial communication
  Serial.begin(9600);

  // Initialize NeoPixel strip
  strip.begin();
  strip.show(); // Turn off all LEDs

  // Initialize pins
  pinMode(TX_PIN_1, OUTPUT);
  pinMode(TX_PIN_2, OUTPUT);
  pinMode(BUTTON_PIN, INPUT_PULLDOWN);

  // Initialize accelerometer
  if (!mpu.begin()) {
    Serial.println("Failed to find MPU6050 chip");
    while (1);
  }
  Serial.println("MPU6050 initialized");

  // Calibrate baselines
  baseline1 = calibrateBaseline(ANALOG_PIN_1, TX_PIN_1);
  baseline2 = calibrateBaseline(ANALOG_PIN_2, TX_PIN_2);

  // Start match timer
  matchStartTime = millis();
}

void loop() {
  // Check if the reset button is pressed
  if (digitalRead(BUTTON_PIN) == HIGH) {
    resetMetrics();
    delay(500); // Debounce delay
  }

  // Sensor 1
  int result1 = txRx(ANALOG_PIN_1, TX_PIN_1);
  int deviation1 = abs(result1 - baseline1);

  // Sensor 2
  int result2 = txRx(ANALOG_PIN_2, TX_PIN_2);
  int deviation2 = abs(result2 - baseline2);

  // Calculate velocity
  velocity = calculateVelocity();

  // Track individual hits and add to cumulative force
  if (deviation1 > STRIKE_THRESHOLD && velocity > accelerationThreshold) {
    oneOffStrikes++;
    cumulativeForce += deviation1;
    totalHits++;
    fighter1Score += (deviation1 > SIGNIFICANT_STRIKE_THRESHOLD) ? 3 : 1;
    if (deviation1 > SIGNIFICANT_STRIKE_THRESHOLD) significantHits++;
  }

  if (deviation2 > STRIKE_THRESHOLD && velocity > accelerationThreshold) {
    oneOffStrikes++;
    cumulativeForce += deviation2;
    totalHits++;
    fighter2Score += (deviation2 > SIGNIFICANT_STRIKE_THRESHOLD) ? 3 : 1;
    if (deviation2 > SIGNIFICANT_STRIKE_THRESHOLD) significantHits++;
  }

  // Apply decay to cumulative force over time
  cumulativeForce *= DECAY_FACTOR;
  if (cumulativeForce < 0) cumulativeForce = 0;

  // Flashing mode if cumulative force exceeds the threshold
  if (cumulativeForce > CUMULATIVE_FORCE_THRESHOLD) {
    redMode = true;
    flashStartTime = millis();
  }

  if (redMode) {
    unsigned long elapsedTime = millis() - flashStartTime;

    if ((elapsedTime / FLASH_INTERVAL) % 2 == 0) {
      strip.fill(strip.Color(255, 0, 0)); // Flash red
    } else {
      strip.fill(strip.Color(0, 0, 0)); // Turn off LEDs
    }

    if (elapsedTime >= FLASH_DURATION) {
      redMode = false; // Stop flashing
      cumulativeForce = 0; // Reset cumulative force
    }
  } else {
    // Determine LED color based on cumulative force
    int red = min((cumulativeForce / CUMULATIVE_FORCE_THRESHOLD) * 255, 255);
    int green = 255 - red;
    strip.fill(strip.Color(red, green, 0)); // Smooth color transition
  }

  strip.show(); // Update the LED strip display

  // Check if the round duration has elapsed
  if (millis() - matchStartTime > ROUND_DURATION) {
    Serial.print("Round over! Fighter 1 Score: ");
    Serial.print(fighter1Score);
    Serial.print(", Fighter 2 Score: ");
    Serial.println(fighter2Score);
    resetMetrics();
    matchStartTime = millis(); // Start the next round
  }

  delay(100); // Loop delay
}
